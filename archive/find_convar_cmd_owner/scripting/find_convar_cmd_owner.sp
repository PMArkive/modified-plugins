#pragma semicolon 1
#pragma newdecls required

#include <sourcemod>

#define PL_VERSION	"2.0"
#define DUMP_PATH_CONVAR	"data/find_convar_cmd_owner/dumpped_convars.txt"
#define DUMP_PATH_COMMAND	"data/find_convar_cmd_owner/dumpped_commands.txt"
#define DEBUG 0
#define DEBUG_MSG 0

enum struct ConVarInfo
{
	char PluginName[256];
	char cvar[256];
	char value[64];
	char flags[256];
	char description[256];
	char min[64];
	char max[64];
}

enum struct CmdInfo
{
	char PluginName[256];
	char cmd[256];
	char adminFlags[256];
	char description[256];	
}

static const char g_sFlags[][] = {
	"FCVAR_UNREGISTERED", "FCVAR_DEVELOPMENTONLY", "FCVAR_GAMEDLL", "FCVAR_CLIENTDLL", //"FCVAR_MATERIAL_SYSTEM",
	"FCVAR_HIDDEN", "FCVAR_PROTECTED", "FCVAR_SPONLY", "FCVAR_ARCHIVE", "FCVAR_NOTIFY",
	"FCVAR_USERINFO", "FCVAR_PRINTABLEONLY", "FCVAR_UNLOGGED", "FCVAR_NEVER_AS_STRING",
	"FCVAR_REPLICATED", "FCVAR_CHEAT", "FCVAR_SS", "FCVAR_DEMO", "FCVAR_DONTRECORD",
	"FCVAR_SS_ADDED", "FCVAR_RELEASE", "FCVAR_RELOAD_MATERIALS", "FCVAR_RELOAD_TEXTURES",
	"FCVAR_NOT_CONNECTED", "FCVAR_MATERIAL_SYSTEM_THREAD", //"FCVAR_ARCHIVE_XBOX",
	"FCVAR_ARCHIVE_GAMECONSOLE", "FCVAR_ACCESSIBLE_FROM_THREADS", "_", "_", "FCVAR_SERVER_CAN_EXECUTE",
	"FCVAR_SERVER_CANNOT_QUERY", "FCVAR_CLIENTCMD_CAN_EXECUTE"
};

static const char g_sAdminFlags[][] = {
    "ADMFLAG_RESERVATION", "ADMFLAG_GENERIC", "ADMFLAG_KICK", "ADMFLAG_BAN",
    "ADMFLAG_UNBAN", "ADMFLAG_SLAY", "ADMFLAG_CHANGEMAP", "ADMFLAG_CONVARS",
    "ADMFLAG_CONFIG", "ADMFLAG_CHAT", "ADMFLAG_VOTE", "ADMFLAG_PASSWORD",
    "ADMFLAG_RCON", "ADMFLAG_CHEATS", "ADMFLAG_ROOT", "ADMFLAG_CUSTOM1",
    "ADMFLAG_CUSTOM2", "ADMFLAG_CUSTOM3", "ADMFLAG_CUSTOM4", "ADMFLAG_CUSTOM5",
    "ADMFLAG_CUSTOM6"
};

bool	  g_bIsAllPluginLoaded = false, g_bIsAllConfigExecuted = false;

ConVar g_hcvarHide, g_hcvarStoreNameType, g_hcvarDumpMore;

KeyValues kv;

ArrayList g_harrConVarInfo = null, g_harrCmdInfo = null, g_harrFindOwnerConVar = null, g_harrFindOwnerCmd = null;

public Plugin myinfo =
{
	name = "[ANY] Find ConVar/Command Owner",
	author = "blueblur, basic method by Bacardi",
	description = "Finds the owner of convars and cmds generated by SourceMod. (An alternative version of dump_all_cmds_cvars by Bacardi)",
	version = PL_VERSION,
	url = "https://github.com/blueblur0730/modified-plugins"
}

public void OnPluginStart()
{
	CreateConVar("find_convar_cmd_owner_version", PL_VERSION, "Version of the plugin.", FCVAR_NOTIFY | FCVAR_DONTRECORD | FCVAR_SPONLY);

	g_hcvarHide			 = CreateConVar("find_convar_cmd_owner_hide", "1", "hide the cvar of this plugin.", _, true, 0.0, true, 1.0);
	g_hcvarStoreNameType = CreateConVar("find_convar_cmd_owner_storenametype", "1", "1 = File and path name, 2 = Descriptive name", _, true, 1.0, true, 2.0);

	// by defualt, cvars have values and cmds have flags in the keyvalue file.
	g_hcvarDumpMore		 = CreateConVar("find_convar_cmd_owner_dumpmore", "1", "dump description and flags of the cvar and cmd, and the bounds of cvar?", _, true, 0.0, true, 1.0);

	RegServerCmd("sm_dumpcvar", Command_DumpCvar, "Dump");
	RegServerCmd("sm_dumpcmd", Command_DumpCmd, "Dump");
	RegServerCmd("sm_find_its_owner", Command_FindItsOwner, "Usage: sm_find_its_owner <cvar/cmd>, the result will appear on the server console.");
	RegServerCmd("sm_find_its_concvar", Command_FindItsConConvar, "Usage: sm_find_its_concvar <plugin_file_name.smx>, the result will appear on the data/find_convar_cmd_owner/<plugin_name>.txt.");
}

public void OnAllPluginsLoaded()
{
	g_bIsAllPluginLoaded = true;
}

public void OnConfigsExecuted()
{
	g_bIsAllConfigExecuted = true;
}

public void OnMapEnd()
{
	g_bIsAllPluginLoaded	= false;
	g_bIsAllConfigExecuted = false;
}

Action Command_DumpCvar(int args)
{
	if (!g_bIsAllPluginLoaded || !g_bIsAllConfigExecuted)
	{
		PrintToServer("All plugin is not loaded or all config is not executed yet.");
		return Plugin_Handled;
	}

	PrintToServer("Dumpping convars...");
	CollectConVars();
	FinaleOutput(false);

	return Plugin_Handled;
}

Action Command_DumpCmd(int args)
{
	if (!g_bIsAllPluginLoaded || !g_bIsAllConfigExecuted)
	{
		PrintToServer("All plugin is not loaded or all config is not executed yet.");
		return Plugin_Handled;
	}

	PrintToServer("Dumpping cmds...");
	CollectCmds();
	FinaleOutput(true);

	return Plugin_Handled;
}

Action Command_FindItsOwner(int args)
{
	if (!g_bIsAllPluginLoaded || !g_bIsAllConfigExecuted)
	{
		PrintToServer("All plugin is not loaded or all config is not executed yet.");
		return Plugin_Handled;
	}

	if (GetCmdArgs() != 1)
	{
		PrintToServer("Usage: sm_find_its_owner <cvar/cmd>");
		return Plugin_Handled;
	}

	char sBuffer[256];
	GetCmdArg(1, sBuffer, sizeof(sBuffer));

	ConVar hCvar = FindConVar(sBuffer);
	if (hCvar != null)
	{
		char sPluginName[256];
		GetPluginFilename(hCvar.Plugin, sPluginName, sizeof(sPluginName));
		PrintToServer("ConVar: %s, Plugin: %s", sBuffer, sPluginName);
	}
	else
	{
		CommandIterator CmdIter = new CommandIterator();
		while (CmdIter.Next())
		{
			if (CmdIter.Plugin != null)
			{
				char sPluginName[256];
				GetPluginFilename(hCvar.Plugin, sPluginName, sizeof(sPluginName));
				if (StrContains(sPluginName, sBuffer) > -1)
				{
					PrintToServer("Cmd: %s, Plugin: %s", sBuffer, sPluginName);
					break;
				}
			}
		}
		delete CmdIter;
	}

	return Plugin_Handled;
}

// from dump_all_cmds_cvars by Bacardi https://forums.alliedmods.net/showthread.php?p=2688799
void CollectConVars()
{
	char sBuffer[256];
	bool bIsCommand = false;
	int	flags = 0;
	Handle hConCmdIter;			// im expecting a convar iterator

	sBuffer[0] = '\0';

	hConCmdIter = FindFirstConCommand(sBuffer, sizeof(sBuffer), bIsCommand, flags);

	if (hConCmdIter == null)
	{
		PrintToServer("No convars or cmds found.");
		return;
	}

	do
	{
		if (sBuffer[0] != '\0' && !bIsCommand)
			StoreBuffers(sBuffer, flags);
	}
	while (FindNextConCommand(hConCmdIter, sBuffer, sizeof(sBuffer), bIsCommand, flags));
	delete hConCmdIter;

	SetKvString_ConVars();
}

void StoreBuffers(const char[] sBuffer, int flags)
{
	if (g_hcvarHide.BoolValue)
	{
		if (strcmp(sBuffer, "find_convar_cmd_owner_version") == 0
			|| strcmp(sBuffer, "find_convar_cmd_owner_hide") == 0
			|| strcmp(sBuffer, "find_convar_cmd_owner_storenametype") == 0
			|| strcmp(sBuffer, "find_convar_cmd_owner_dumpmore") == 0)
			return;
	}

	if (g_harrConVarInfo == null)
		g_harrConVarInfo = new ArrayList(sizeof(ConVarInfo));

	ConVar hCvar = FindConVar(sBuffer);
	if (hCvar == null)
		return;

	ConVarInfo esConVarInfo;
	char sPluginName[256];
	if (hCvar.Plugin != null)
	{
		if (g_hcvarStoreNameType.IntValue == 1)
			GetPluginFilename(hCvar.Plugin, sPluginName, sizeof(sPluginName));
		else
			GetPluginInfo(hCvar.Plugin, PlInfo_Name, sPluginName, sizeof(sPluginName));

		if (StrContains(sPluginName, "/") > -1)
			ReplaceString(sPluginName, sizeof(sPluginName), "/", " | ");
		
		hCvar.GetDefault(esConVarInfo.value, sizeof(esConVarInfo.value));
		esConVarInfo.PluginName = sPluginName;
		hCvar.GetName(esConVarInfo.cvar, sizeof(esConVarInfo.cvar));

		if (g_hcvarDumpMore.BoolValue)
		{
			hCvar.GetDescription(esConVarInfo.description, sizeof(esConVarInfo.description));
			if (flags == 0)
				Format(esConVarInfo.flags, sizeof(esConVarInfo.flags), "FCVAR_NONE");
			else
			{
				for (int i = 0; i < sizeof(g_sFlags); i++)
				{
					if (flags & (1 << i))
					{
						#if DEBUG_MSG
							PrintToServer("i: %d, flags: %s", i, g_sFlags[i]);
						#endif
						Format(esConVarInfo.flags, sizeof(esConVarInfo.flags), "%s | %s", esConVarInfo.flags, g_sFlags[i]);
					}	
				}
				// wtf
				ReplaceStringEx(esConVarInfo.flags, sizeof(esConVarInfo.flags), " | ", "", 1);
				ReplaceStringEx(esConVarInfo.flags, sizeof(esConVarInfo.flags), "|", "");
				ReplaceStringEx(esConVarInfo.flags, sizeof(esConVarInfo.flags), " ", "");
			}

			float fMin, fMax;
			if (hCvar.GetBounds(ConVarBound_Lower, fMin))
				Format(esConVarInfo.min, sizeof(esConVarInfo.min), "%.02f", fMin);
			else
				esConVarInfo.min = "no limit";
			if (hCvar.GetBounds(ConVarBound_Upper, fMax))
				Format(esConVarInfo.max, sizeof(esConVarInfo.max), "%.02f", fMax);
			else
				esConVarInfo.max = "no limit";
		}
		g_harrConVarInfo.PushArray(esConVarInfo);
	}
}

void CollectCmds()
{
	char sBuffer[256];
	CmdInfo esCmdInfo;

	if (g_harrCmdInfo == null)
		g_harrCmdInfo = new ArrayList(sizeof(CmdInfo));

	CommandIterator CmdIter = new CommandIterator();
	while (CmdIter.Next())
	{
		CmdIter.GetName(sBuffer, sizeof(sBuffer));

		if (g_hcvarHide.BoolValue)
		{
			if (StrContains(sBuffer, "sm_dumpcvar") > -1
				|| StrContains(sBuffer, "sm_dumpcmd") > -1)
				continue;
		}

		if (g_hcvarDumpMore.BoolValue)
			CmdIter.GetDescription(esCmdInfo.description, sizeof(esCmdInfo.description));

		esCmdInfo.cmd = sBuffer;

		if (CmdIter.Plugin != null)
		{
			char sPluginName[256];
			if (g_hcvarStoreNameType.IntValue == 1)
				GetPluginFilename(CmdIter.Plugin, sPluginName, sizeof(sPluginName));
			else
				GetPluginInfo(CmdIter.Plugin, PlInfo_Name, sPluginName, sizeof(sPluginName));

			if (StrContains(sPluginName, "/") > -1)
				ReplaceString(sPluginName, sizeof(sPluginName), "/", " | ");

			esCmdInfo.PluginName = sPluginName;

			if (CmdIter.AdminFlags == 0)
				Format(esCmdInfo.adminFlags, sizeof(esCmdInfo.adminFlags), "ADMFLAG_NULL");
			else
			{
                // Get the highest admin flag of the command
				int admFlags = CmdIter.AdminFlags;
                int i = AdminFlags_TOTAL;

				while (i > 0)
				{
					if (admFlags & (1 << i))
					{
						#if DEBUG_MSG
							PrintToServer("i: %d, name: %s, flags: %s", i, esCmdInfo.cmd, g_sAdminFlags[i]);
						#endif
						Format(esCmdInfo.adminFlags, sizeof(esCmdInfo.adminFlags), "%s", g_sAdminFlags[i]);
                        break;
					}
					i--;
				}
			}
		}
		g_harrCmdInfo.PushArray(esCmdInfo);
	}
	delete CmdIter;
	SetKvString_Cmds();
}

void SetKvString_ConVars()
{
	ConVarInfo esConVarInfo;
	char key[128], value[128], flags[128], description[128], min[128], max[128];

	if (kv == null)
		kv = new KeyValues("ConVars");

	for (int i = 0; i < g_harrConVarInfo.Length; i++)
	{
		g_harrConVarInfo.GetArray(i, esConVarInfo);
		#if DEBUG
			PrintToServer("Plugin: %s, Cvar: %s", esConVarInfo.PluginName, esConVarInfo.cvar);
		#endif
 		if (kv.JumpToKey(esConVarInfo.PluginName, true))
		{
			#if DEBUG
				PrintToServer("jumping to: %s", esConVarInfo.PluginName);
			#endif
			if (g_hcvarDumpMore.BoolValue)
			{
				kv.Rewind();
				Format(value, sizeof(value), "%s/%s/defvalue", esConVarInfo.PluginName, esConVarInfo.cvar);
				kv.SetString(value, esConVarInfo.value);
				Format(flags, sizeof(flags), "%s/%s/flags", esConVarInfo.PluginName, esConVarInfo.cvar);
				kv.SetString(flags, esConVarInfo.flags);
				Format(description, sizeof(description), "%s/%s/description", esConVarInfo.PluginName, esConVarInfo.cvar);
				kv.SetString(description, esConVarInfo.description);
				Format(min, sizeof(min), "%s/%s/min", esConVarInfo.PluginName, esConVarInfo.cvar);
				kv.SetString(min, esConVarInfo.min);
				Format(max, sizeof(max), "%s/%s/max", esConVarInfo.PluginName, esConVarInfo.cvar);
				kv.SetString(max, esConVarInfo.max);
			}
			else
			{
				kv.Rewind();
				Format(key, sizeof(key), "%s/%s", esConVarInfo.PluginName, esConVarInfo.cvar);
				kv.SetString(key, esConVarInfo.value);
			}
		}
		kv.Rewind();
	}
	delete g_harrConVarInfo;
}

void SetKvString_Cmds()
{
	if (kv == null)
		kv = new KeyValues("Commands");

	CmdInfo esCmdInfo;
	char key[128], flags[128], description[128];
	for (int i = 0; i < g_harrCmdInfo.Length; i++)
	{
		g_harrCmdInfo.GetArray(i, esCmdInfo);
		#if DEBUG
			PrintToServer("Plugin: %s, Cmd: %s", esCmdInfo.PluginName, esCmdInfo.cmd);
		#endif
		if (kv.JumpToKey(esCmdInfo.PluginName, true))
		{
			#if DEBUG
				PrintToServer("jumping to: %s", esCmdInfo.PluginName);
			#endif
			if (g_hcvarDumpMore.BoolValue)
			{
				kv.Rewind();
				Format(flags, sizeof(flags), "%s/%s/flags", esCmdInfo.PluginName, esCmdInfo.cmd);
				kv.SetString(flags, esCmdInfo.adminFlags);
				Format(description, sizeof(description), "%s/%s/description", esCmdInfo.PluginName, esCmdInfo.cmd);
				kv.SetString(description, esCmdInfo.description);
			}
			else
			{
				kv.Rewind();
				Format(key, sizeof(key), "%s/%s", esCmdInfo.PluginName, esCmdInfo.cmd);
				kv.SetString(key, esCmdInfo.adminFlags);
			}
		}
		kv.Rewind();
	}
	delete g_harrCmdInfo;
}

void FinaleOutput(bool bIsCommand)
{
	char sDumpPath[PLATFORM_MAX_PATH];
	BuildPath(Path_SM, sDumpPath, sizeof(sDumpPath), bIsCommand ? DUMP_PATH_COMMAND: DUMP_PATH_CONVAR);
	kv.Rewind();
	kv.ExportToFile(sDumpPath);
	PrintToServer("Dumpping completed.");
	delete kv;
}

Action Command_FindItsConConvar(int args)
{
	if (!g_bIsAllPluginLoaded || !g_bIsAllConfigExecuted)
	{
		PrintToServer("All plugin is not loaded or all config is not executed yet.");
		return Plugin_Handled;
	}

	if (GetCmdArgs() != 1)
	{
		PrintToServer("Usage: sm_find_its_concvar <plugin_file_name>");
		return Plugin_Handled;
	}

	char sBuffer[256];
	GetCmdArg(1, sBuffer, sizeof(sBuffer));
	PrintToServer("Dumpping the convars and cmds of this plugin: %s", sBuffer);

	PluginIterator hIter = new PluginIterator();
	char sPluginName[256]; Handle hPlugin;
	while (hIter.Next())
	{
        // Mitigate crash, more info: 
        // https://github.com/alliedmodders/sourcemod/issues/1880
		if (hIter.Plugin != null)
		{
			GetPluginFilename(hIter.Plugin, sPluginName, sizeof(sPluginName));

			if (StrContains(sPluginName, sBuffer) > -1)
			{
				if (StrContains(sPluginName, "/") > -1)
					ReplaceString(sPluginName, sizeof(sPluginName), "/", " | ");

				hPlugin = hIter.Plugin;
				break;
			}
		}
	}
	delete hIter;

	char sConCommand[256]; bool bIsCommand; int flags = 0;
	Handle hConCmdIter = FindFirstConCommand(sConCommand, sizeof(sConCommand), bIsCommand, flags);
	if (hConCmdIter != null)
	{
		do
		{
			if (sConCommand[0] != '\0')
			{
				FindConCommand(sConCommand, bIsCommand, hPlugin, flags);
			}
		}
		while (FindNextConCommand(hConCmdIter, sConCommand, sizeof(sConCommand), bIsCommand, flags));
		delete hConCmdIter;
	}
	SetKvString_FindOwner(sPluginName);

	return Plugin_Handled;
}

void FindConCommand(const char[] sConCommand, bool bIsCommand, Handle hPlugin, int flags)
{
	if (!bIsCommand)
	{
		ConVar hCvar = FindConVar(sConCommand);
		if (hCvar == null)
			return;

		if (hCvar.Plugin != hPlugin)
			return;

		ConVarInfo esConVarInfo;
		if (g_harrFindOwnerConVar == null)
			g_harrFindOwnerConVar = new ArrayList(sizeof(ConVarInfo));
		
		strcopy(esConVarInfo.cvar, sizeof(esConVarInfo.cvar), sConCommand);
		hCvar.GetDefault(esConVarInfo.value, sizeof(esConVarInfo.value));
		if (g_hcvarDumpMore.BoolValue)
		{
			if (flags == 0)
				Format(esConVarInfo.flags, sizeof(esConVarInfo.flags), "FCVAR_NONE");
			else
			{
				for (int i = 0; i < sizeof(g_sFlags); i++)
				{
					if (flags & (1 << i))
					{
						#if DEBUG_MSG
							PrintToServer("i: %d, flags: %s", i, g_sFlags[i]);
						#endif
						Format(esConVarInfo.flags, sizeof(esConVarInfo.flags), "%s | %s", esConVarInfo.flags, g_sFlags[i]);
					}	
				}
				// wtf
				ReplaceStringEx(esConVarInfo.flags, sizeof(esConVarInfo.flags), " | ", "", 1);
				ReplaceStringEx(esConVarInfo.flags, sizeof(esConVarInfo.flags), "|", "");
				ReplaceStringEx(esConVarInfo.flags, sizeof(esConVarInfo.flags), " ", "");
			}
			hCvar.GetDescription(esConVarInfo.description, sizeof(esConVarInfo.description));
			float fMin, fMax;
			if (hCvar.GetBounds(ConVarBound_Lower, fMin))
				Format(esConVarInfo.min, sizeof(esConVarInfo.min), "%.02f", fMin);
			else
				esConVarInfo.min = "no limit";
			if (hCvar.GetBounds(ConVarBound_Upper, fMax))
				Format(esConVarInfo.max, sizeof(esConVarInfo.max), "%.02f", fMax);
			else
				esConVarInfo.max = "no limit";
		}
		g_harrFindOwnerConVar.PushArray(esConVarInfo);
	}
	else
	{
		CmdInfo esCmdInfo;
		if (g_harrFindOwnerCmd == null)
			g_harrFindOwnerCmd = new ArrayList(sizeof(CmdInfo));

		CommandIterator CmdIter = new CommandIterator();
		while (CmdIter.Next())
		{
			if (CmdIter.Plugin != null)
			{
				if (CmdIter.Plugin != hPlugin)
					continue;

				if (g_hcvarDumpMore.BoolValue)
				{
					CmdIter.GetDescription(esCmdInfo.description, sizeof(esCmdInfo.description));
					if (esCmdInfo.description[0] == '\0')
						esCmdInfo.description = "_";
				}

				CmdIter.GetName(esCmdInfo.cmd, sizeof(esCmdInfo.cmd));

                if (CmdIter.AdminFlags == 0)
				    Format(esCmdInfo.adminFlags, sizeof(esCmdInfo.adminFlags), "ADMFLAG_NULL");
                else
                {
                    // Get the highest admin flag of the command
                    int admFlags = CmdIter.AdminFlags;
                    int i = AdminFlags_TOTAL;

                    while (i > 0)
                    {
                        if (admFlags & (1 << i))
                        {
                            #if DEBUG_MSG
                                PrintToServer("i: %d, name: %s, flags: %s", i, esCmdInfo.cmd, g_sAdminFlags[i]);
                            #endif
                            Format(esCmdInfo.adminFlags, sizeof(esCmdInfo.adminFlags), "%s", g_sAdminFlags[i]);
                            break;
                        }
                        i--;
                    }
                }
            }
			g_harrFindOwnerCmd.PushArray(esCmdInfo);
		}
		delete CmdIter;
	}
}

void SetKvString_FindOwner(const char[] sPluginName)
{
	if (kv == null)
		kv = new KeyValues(sPluginName);

	CmdInfo esCmdInfo; ConVarInfo esConVarInfo;
	if (g_harrFindOwnerCmd.Length != 0)
	{
		char key[128], flags[128], description[128];
		for (int i = 0; i < g_harrFindOwnerCmd.Length; i++)
		{
			g_harrFindOwnerCmd.GetArray(i, esCmdInfo);
			if (kv.JumpToKey("Commands", true))
			{
				if (g_hcvarDumpMore.BoolValue)
				{
					kv.Rewind();
					Format(flags, sizeof(flags), "Commands/%s/flags", esCmdInfo.cmd);
					kv.SetString(flags, esCmdInfo.adminFlags);
					Format(description, sizeof(description), "Commands/%s/description", esCmdInfo.cmd);
					kv.SetString(description, esCmdInfo.description);
				}
				else
				{
					kv.Rewind();
					Format(key, sizeof(key), "Commands/%s", esCmdInfo.cmd);
					kv.SetString(key, esCmdInfo.adminFlags);
				}
			}
		}
		delete g_harrFindOwnerCmd;
	}

	if (g_harrFindOwnerConVar.Length != 0)
	{

		char key[128], value[128], flags[128], description[128], min[128], max[128];
		for (int i = 0; i < g_harrFindOwnerConVar.Length; i++)
		{
			g_harrFindOwnerConVar.GetArray(i, esConVarInfo);
			if (kv.JumpToKey("ConVars", true))
			{
				if (g_hcvarDumpMore.BoolValue)
				{
					kv.Rewind();
					Format(value, sizeof(value), "ConVars/%s/defvalue", esConVarInfo.cvar);
					kv.SetString(value, esConVarInfo.value);
					Format(flags, sizeof(flags), "ConVars/%s/flags", esConVarInfo.cvar);
					kv.SetString(flags, esConVarInfo.flags);
					Format(description, sizeof(description), "ConVars/%s/description", esConVarInfo.cvar);
					kv.SetString(description, esConVarInfo.description);
					Format(min, sizeof(min), "ConVars/%s/min", esConVarInfo.cvar);
					kv.SetString(min, esConVarInfo.min);
					Format(max, sizeof(max), "ConVars/%s/max", esConVarInfo.cvar);
					kv.SetString(max, esConVarInfo.max);
				}
				else
				{
					kv.Rewind();
					Format(key, sizeof(key), "ConVars/%s", esConVarInfo.cvar);
					kv.SetString(key, esConVarInfo.value);
				}
			}
		}
		delete g_harrFindOwnerConVar;
	}

	char sDumpPath[PLATFORM_MAX_PATH];
	BuildPath(Path_SM, sDumpPath, sizeof(sDumpPath), "data/find_convar_cmd_owner/%s.txt", sPluginName);
	kv.Rewind();
	kv.ExportToFile(sDumpPath);
	PrintToServer("Dumpping completed.");
	delete kv;
}

/**
 * BUG: there's an unsolved problem with kv.GoToNextKey() loop function. The keyvalue has already jumpped onto the key we need to check,
 * While there's no any other sub key under the current key, kv.GoToNextKey() should return false and integer a should no longer increase. but it dosen't.
 * I've checked it has nothing to do with arraylist nor enum struct, it's a pure keyvalue problem of kv.GoToNextKey() or kv.JumpToKey() function, or the speed of the loop maybe.
 * This problem finally cause the dumpped keyvalue file has a unregular sequence of cvar keys.
*/

/**
 * 
 * 		if (kv.JumpToKey(esConVarInfo.PluginName, true))
		{
			#if DEBUG
				PrintToServer("jumping to: %s", esConVarInfo.PluginName);
			#endif
				
			int a = 0;
			while (kv.GotoNextKey())
			{
				a += 1;
				#if DEBUG
					PrintToServer("time we loopped: %d", a);
				#endif
			}

			kv.Rewind();
			Format(key, sizeof(key), "%s/cvar%d", esConVarInfo.PluginName, a);
			kv.SetString(key, esConVarInfo.cvar);
		}
*/